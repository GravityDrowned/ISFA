<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A000368.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A000368">
          <assertion class="***** TTTT *****">
      <CMP> M3365 N1356</CMP>
    </assertion><omtext class="starts-with">
      <CMP> 1,1,4,9,28,71,202,542,1507,4114,11381,31349,86845,240567,668553,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 1860361,5188767,14495502,40572216,113743293,319405695,898288484,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 2530058013,7135848125,20152898513,56986883801</CMP>
    </assertion><omtext class="name">
      <CMP> Number of connected graphs with one cycle of length 4.</CMP>
    </omtext><omtext class="reference">
      <CMP> J. Riordan, An Introduction to Combinatorial Analysis, Wiley, 1958, p. 150.</CMP>
    </omtext><omtext class="reference">
      <CMP> N. J. A. Sloane, A Handbook of Integer Sequences, Academic Press, 1973 (includes this sequence).</CMP>
    </omtext><omtext class="reference">
      <CMP> N. J. A. Sloane and Simon Plouffe, The Encyclopedia of Integer Sequences, Academic Press, 1995 (includes this sequence).</CMP>
    </omtext><omtext class="reference">
      <CMP> F. Harary and E. Palmer, Graphical Enumeration, Academic Press, 1973, page 69.</CMP>
    </omtext><omtext class="link">
      <CMP> Sean A. Irvine and Washington Bomfim, &lt;a href=&quot;/A000368/b000368.txt&quot;&gt;Table of n, a(n) for n = 4..200&lt;/a&gt; (terms n=4..43 computed by Sean A. Irvine)</CMP>
    </omtext><omtext class="link">
      <CMP> Frank Ruskey, &lt;a href=&quot;http://www.1stworks.com/ref/RuskeyCombGen.pdf&quot;&gt;Combinatorial Generation Algorithm 4.26, p. 96&lt;/a&gt;</CMP>
    </omtext><omdoc:p class="formula">
        <CMP>
         a(n) = Sum_(P){ g(p,a) }, where<OMOBJ>
      <OMV name="P"/>
    </OMOBJ> is the set of the partitions<OMOBJ>
      <OMV name="p"/>
    </OMOBJ> of<OMOBJ>
      <OMV name="n"/>
    </OMOBJ> with four parts, each<OMOBJ>
      <OMV name="p"/>
    </OMOBJ> as<OMOBJ>
      <OMV name="a"/>
    </OMOBJ> vector of nP distinct parts: p[1],<OMOBJ>
      <OMA>
      <OMS name="p" cd="A000368"/>
      <OMI>2</OMI>
    </OMA>
    </OMOBJ>,<OMOBJ>
      <OMS name="..." cd="arithmetics"></OMS>
    </OMOBJ>,<OMOBJ>
      <OMA>
      <OMS name="p" cd="A000368"/>
      <OMV name="nP"/>
    </OMA>
    </OMOBJ>, with frequencies respectively a[1],a[2],<OMOBJ>
      <OMS name="..." cd="arithmetics"></OMS>
    </OMOBJ>,<OMOBJ>
      <OMA>
      <OMS name="a" cd="A000368"/>
      <OMV name="nP"/>
    </OMA>
    </OMOBJ>,<OMOBJ>
      <OMA>
      <OMS name="=" cd="arithmetic"/>
      <OMA>
      <OMS name="a" cd="A000368"/>
      <OMI>1</OMI>
    </OMA>
      <OMA>
      <OMS name="max" cd="A000368"/>
      <OMA>
      <OMS name="a" cd="A000368"/>
      <OMV name="i"/>
    </OMA>
    </OMA>
    </OMA>
    </OMOBJ>, i = 1..nP). C(,) is<OMOBJ>
      <OMV name="a"/>
    </OMOBJ> binomial coefficient,<OMOBJ>
      <OMA>
      <OMS name="=" cd="arithmetic"/>
      <OMV name="f"/>
      <OMR xref="A000081"/>
    </OMA>
    </OMOBJ>, and<OMOBJ>
      <OMA>
      <OMS name="g" cd="A000368"/>
      <OMV name="p"/><OMV name="a"/>
    </OMA>
    </OMOBJ> is given below.
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
                 | 2*f(p[1]) + 3*C(f(p[1]),2)) * f(p[2]) * f(p[3])     if nP = 3,
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
                 | 3 * f(p[1]) * f(p[2]) * f(p[3]) * f(p[4])           if nP = 4,
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
                 | 3 * C(f(p[1]),2) * C(f(p[2]),2) + 2 * f(p[2]) * C(f(p[1]),2) +
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
         g(p,a)= &lt; 2 * (f(p[1]) * (C(f(p[2]),2) + f(p[2]))) if<OMOBJ>
      <OMA>
      <OMS name="=" cd="arithmetic"/>
      <OMV name="nP"/>
      <OMI>2</OMI>
    </OMA>
    </OMOBJ>, and<OMOBJ>
      <OMA>
      <OMS name="=" cd="arithmetic"/>
      <OMA>
      <OMS name="a" cd="A000368"/>
      <OMI>1</OMI>
    </OMA>
      <OMI>2</OMI>
    </OMA>
    </OMOBJ>,
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
                 | f(p[2])*( f(p[1]) + 3*C(f(p[1]),3) + 2*f(p[1]) * (f(p[1])-1) )
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
                 |                                       if nP = 2, and<OMOBJ>
      <OMA>
      <OMS name="=" cd="arithmetic"/>
      <OMA>
      <OMS name="a" cd="A000368"/>
      <OMI>1</OMI>
    </OMA>
      <OMI>3</OMI>
    </OMA>
    </OMOBJ>,
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
                 | f(p[1])*(2*f(p[1])-1+2*C(f(p[1])-1,2))+3*C(f(p[1]),4) if<OMOBJ>
      <OMA>
      <OMS name="=" cd="arithmetic"/>
      <OMV name="nP"/>
      <OMI>1</OMI>
    </OMA>
    </OMOBJ>.
      </CMP>
      </omdoc:p><omdoc:p class="formula">
        <CMP>
         # Washington Bomfim, Jul 19 2012
      </CMP>
      </omdoc:p><omtext class="mathematica">
      <CMP> Needs[&quot;Combinatorica`&quot;]; nn = 30; s[n_, k_] := s[n, k] = a[n + 1 - k] + If[n &lt; 2 k, 0, s[n - k, k]]; a[1] = 1; a[n_] := a[n] = Sum[a[i] s[n - 1, i] i, {i, 1, n - 1}]/(n - 1); rt = Table[a[i], {i, 1, nn}]; Take[CoefficientList[CycleIndex[DihedralGroup[4], s] /. Table[s[j] -&gt; Table[Sum[rt[[i]] x^(k*i), {i, 1, nn}], {k, 1, nn}][[j]], {j, 1, nn}], x], {5, nn}] (* after code given by Robert A Russel in A000081, _Geoffrey Critzer_, Oct 12 2012 *)</CMP>
    </omtext><omtext class="program">
      <CMP> (PARI)</CMP>
    </omtext><omtext class="program">
      <CMP> max_n = 200; f = vector(max_n);         \\ f[n] = A000081[n], n=1..max_n</CMP>
    </omtext><omtext class="program">
      <CMP> sum2(k) = {local(s); s=0; fordiv(k, d, s += d*f[d]); return(s)};</CMP>
    </omtext><omtext class="program">
      <CMP> Init_f()={f[1]=1;</CMP>
    </omtext><omtext class="program">
      <CMP> for(n =1, max_n -2, s=0; for(k=1, n, s+=sum2(k)*f[n-k+1]); f[n+1]=s/n)};</CMP>
    </omtext><omtext class="program">
      <CMP> S; P=[0,1,1,1,1,0]; nP; a=[0,0,0,0,0]; p=[0,0,0,0,0];</CMP>
    </omtext><omtext class="program">
      <CMP> C(x, y) = binomial(x, y);</CMP>
    </omtext><omtext class="program">
      <CMP> g()={if(nP==3, S+=(2*f[p[1]] + 3*C(f[p[1]],2))*f[p[2]]*f[p[3]];return());</CMP>
    </omtext><omtext class="program">
      <CMP> if(nP == 4, S += 3 * f[p[1]] * f[p[2]] * f[p[3]] * f[p[4]]; return());</CMP>
    </omtext><omtext class="program">
      <CMP> if((nP==2)&amp;&amp;(a[1]==2),</CMP>
    </omtext><omtext class="program">
      <CMP> S += 3*C(f[p[1]],2)*C(f[p[2]],2) +</CMP>
    </omtext><omtext class="program">
      <CMP> 2*f[p[2]]*C(f[p[1]],2) + 2*(f[p[1]]*(C(f[p[2]],2)+f[p[2]])); return());</CMP>
    </omtext><omtext class="program">
      <CMP> if((nP==2)&amp;&amp;(a[1]==3),</CMP>
    </omtext><omtext class="program">
      <CMP> S += f[p[2]] * (f[p[1]] + 3*C(f[p[1]],3) + 2*f[p[1]]*(f[p[1]]-1));return());</CMP>
    </omtext><omtext class="program">
      <CMP> S += f[p[1]] * ( 2*f[p[1]] - 1 + 2*C(f[p[1]]-1,2) ) + 3*C(f[p[1]],4);</CMP>
    </omtext><omtext class="program">
      <CMP> }</CMP>
    </omtext><omtext class="program">
      <CMP> Convert()={i=3; k=2; x=P[2]; nP=0;  \\ Convert partition P to (nP, p, a)</CMP>
    </omtext><omtext class="program">
      <CMP> while(1, while(P[i] == x, i++); nP++; p[nP] = P[k]; a[nP] = i-k;</CMP>
    </omtext><omtext class="program">
      <CMP>    if(a[nP] &gt; a[1],b=a[1]; a[1]=a[nP]; a[nP]=b; b=p[1]; p[1]=p[nP];p[nP]=b);</CMP>
    </omtext><omtext class="program">
      <CMP>    if(P[i] == 0, g(); return()); x = P[i]; k = i; i++)</CMP>
    </omtext><omtext class="program">
      <CMP> }</CMP>
    </omtext><omtext class="program">
      <CMP>                                         \\ F. Ruskey partition generator</CMP>
    </omtext><omtext class="program">
      <CMP> Part(n, k, s, t) = { P[t] = s;</CMP>
    </omtext><omtext class="program">
      <CMP> if((k == 1) || (n == k), Convert(), L = max(1, ceil((n - s)/(k - 1)));</CMP>
    </omtext><omtext class="program">
      <CMP> for(j = L, min(s, n-s-k+2), Part(n-s, k-1, j, t+1))); P[t] = 1; };</CMP>
    </omtext><omtext class="program">
      <CMP> \\</CMP>
    </omtext><omtext class="program">
      <CMP> A(n) = {S=0; Part(2*n, 4+1, n, 1); return(S)}</CMP>
    </omtext><omtext class="program">
      <CMP> Init_f(); for(n=4, max_n, print(n, &quot; &quot;, A(n)))          \\ b-file format</CMP>
    </omtext><omtext class="program">
      <CMP> \\ # Washington Bomfim, Jul 19 2012</CMP>
    </omtext><assertion class="crossref">
      <CMP> Cf. A000226, A001429, A005703, A000081.</CMP>
    </assertion><assertion class="keywords">
      <CMP> nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 4,3</CMP>
    </assertion><assertion class="author">
      <CMP> _N. J. A. Sloane_.</CMP>
    </assertion><assertion class="extensions">
      <CMP> More terms from _Vladeta Jovovic_, Apr 20 2000</CMP>
    </assertion><assertion class="extensions">
      <CMP> Definition improved by _Franklin T. Adams-Watters_, May 16 2006</CMP>
    </assertion><assertion class="extensions">
      <CMP> More terms from _Sean A. Irvine_, Nov 14 2010</CMP>
    </assertion>
        </theory>
      </omdoc>