<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A245907.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A245907">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 0,1,1,3,0,4,3,3,1,7,2,7,1,3,4,8,1,11,2,3,2,9,2,7,1,9,2,15,0,13,7,3,1,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 7,2,11,3,3,2,19,1,15,2,5,2,11,2,13,1,3,3,15,2,7,4,5,2,15,1,15,1,6,8,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 7,1,15,5,3,1,29,3,14,2,5,4,9,2,23,3,13,1,15</CMP>
    </assertion><omtext class="name">
      <CMP> Let D = {d(n,i)}, i = 1..q, denote the set of divisors of n; then a(n) = number of multiplicative groups G(n,p) = D/kZ, 1 &lt; k &lt; n.</CMP>
    </omtext><omtext class="comment">
      <CMP> We introduce the structure of a finite group in order to study the divisors of each integer.</CMP>
    </omtext><omtext class="comment">
      <CMP> We see that the study of the classification of the divisors is dependent on the values k. The trivial group {1} is counted.</CMP>
    </omtext><omtext class="comment">
      <CMP> The principle of the algorithm is to compute all the products d(n,i)/kZ * d(n,j)/kZ and also the inverse of each element such that if x is in the group, then there exists x’ in the group with x*x’ = 1.</CMP>
    </omtext><omtext class="comment">
      <CMP> An interesting property: a(n)= 0 for n = 2, 6, 30, 186, 366, 426, 606, 786, 1266, 1446, 1626, 1686, ... where n&gt;30 is of the form n = 6*q with q prime of the form (10*k + 1) =&gt; q = 31, 61, 71, 101, 131, 211, 241, 271, 281, 311, 421, 491, ...</CMP>
    </omtext><omtext class="comment">
      <CMP> a(n) = 1 for n = 3, 4, 10, 14, 18, 26, 34, 42, 50, 60, 62, 66, ...</CMP>
    </omtext><omtext class="link">
      <CMP> Michel Lagneau, &lt;a href=&quot;/A245907/b245907.txt&quot;&gt;Table of n, a(n) for n = 2..2000&lt;/a&gt;</CMP>
    </omtext><omtext class="link">
      <CMP> Eric Weisstein's World of Mathematics, &lt;a href=&quot;http://mathworld.wolfram.com/FiniteGroup.html&quot;&gt;Finite Group&lt;/a&gt;</CMP>
    </omtext><omtext class="link">
      <CMP> Wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Finite_group&quot;&gt;Finite group&lt;/a&gt;</CMP>
    </omtext><assertion class="example">
      <CMP> a(133) = 11 because there exist eleven finite groups formed from the four divisors {1,7,19,133} of 133. The eleven finite groups G(133,p) are:</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,2) = {1}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,3} = {1}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,4} = {1,3}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,5} = {1,2,3,4}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,6} = {1}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,8} = {1,3,5,7}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,10} = {1,3,7,9}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,12} = {1,7}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,15} = {1,4,7,13}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,24} = {1,7,13,19}</CMP>
    </assertion><assertion class="example">
      <CMP> G(133,30} = {1,7,13,19}</CMP>
    </assertion><omtext class="maple">
      <CMP> with(numtheory):</CMP>
    </omtext><omtext class="maple">
      <CMP> for n from 2 to 100 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>   x:=divisors(n):n1:=nops(x):ind:=0:</CMP>
    </omtext><omtext class="maple">
      <CMP>     for p from 2 to n-1 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>       lst:={}:</CMP>
    </omtext><omtext class="maple">
      <CMP>         for i from 1 to n1 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>          lst:=lst union {irem(x[i],p)}:</CMP>
    </omtext><omtext class="maple">
      <CMP>         od:</CMP>
    </omtext><omtext class="maple">
      <CMP>          n2:=nops(lst):lst1:={}:</CMP>
    </omtext><omtext class="maple">
      <CMP>           for a from 1 to n2 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>             for b from 1 to n2 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>              lst1:=lst1 union {irem(lst[a]*lst[b],p)}:</CMP>
    </omtext><omtext class="maple">
      <CMP>             od:</CMP>
    </omtext><omtext class="maple">
      <CMP>           od:</CMP>
    </omtext><omtext class="maple">
      <CMP>           if lst1=lst</CMP>
    </omtext><omtext class="maple">
      <CMP>           then</CMP>
    </omtext><omtext class="maple">
      <CMP>           n3:=nops(lst1):lst2:={}:</CMP>
    </omtext><omtext class="maple">
      <CMP>             for c from 1 to n3 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>               for d from 1 to n3 do:</CMP>
    </omtext><omtext class="maple">
      <CMP>                if irem(lst1[c]*lst1[d],p)=1</CMP>
    </omtext><omtext class="maple">
      <CMP>                then lst2:=lst2 union {lst1[c]}:</CMP>
    </omtext><omtext class="maple">
      <CMP>                else</CMP>
    </omtext><omtext class="maple">
      <CMP>                fi:</CMP>
    </omtext><omtext class="maple">
      <CMP>               od:</CMP>
    </omtext><omtext class="maple">
      <CMP>              od:</CMP>
    </omtext><omtext class="maple">
      <CMP>              if lst2=lst</CMP>
    </omtext><omtext class="maple">
      <CMP>               then</CMP>
    </omtext><omtext class="maple">
      <CMP>               ind:=ind+1:</CMP>
    </omtext><omtext class="maple">
      <CMP>               else</CMP>
    </omtext><omtext class="maple">
      <CMP>              fi:</CMP>
    </omtext><omtext class="maple">
      <CMP>            fi:</CMP>
    </omtext><omtext class="maple">
      <CMP>          od:</CMP>
    </omtext><omtext class="maple">
      <CMP>         printf(`%d, `,ind):</CMP>
    </omtext><omtext class="maple">
      <CMP>       od:</CMP>
    </omtext><assertion class="keywords">
      <CMP> nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 2,4</CMP>
    </assertion><assertion class="author">
      <CMP> _Michel Lagneau_, Nov 13 2014</CMP>
    </assertion>
        </theory>
      </omdoc>