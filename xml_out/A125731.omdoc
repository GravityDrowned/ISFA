<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A125731.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A125731">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 0,2,1,1,6,1,3,8,1,5,5,1,2,15,1,7,7,1,12,4,1,4,9,1,9,9,1,14,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 14,1,6,19,1,6,11,1,11,11,1,3,29,1,16,16,1,8,8,1,8,21,1,8,13,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 1,26,13,1,13,13,1,5,31,1,18,18,1,5,23,1,10</CMP>
    </assertion><assertion class="notsupported">
      <CMP>Unexpected tag!</CMP>
    </assertion><assertion class="notsupported">
      <CMP>Unexpected tag!</CMP>
    </assertion><assertion class="notsupported">
      <CMP>Unexpected tag!</CMP>
    </assertion><omtext class="name">
      <CMP> a(n) = minimal number of steps to get from 1 to n, where a step is x -&gt; 3x+1 if x is odd, or x -&gt; either x/2 or 3x+1 if x is even. Set a(n) = -1 if n cannot be reached from 1.</CMP>
    </omtext><omtext class="comment">
      <CMP> In contrast to the &quot;3x+1&quot; problem, here you are free to choose either step if x is even.</CMP>
    </omtext><omtext class="comment">
      <CMP> Clearly a(3k) = -1 for all k; we conjecture that a(n) &gt;= 0 otherwise.</CMP>
    </omtext><omtext class="comment">
      <CMP> See A127885 for the number of steps in the reverse direction, from n to 1.</CMP>
    </omtext><omtext class="link">
      <CMP> David Applegate, &lt;a href=&quot;/A125731/b125731.txt&quot;&gt;Table of n, a(n) for n = 1..1000&lt;/a&gt;</CMP>
    </omtext><assertion class="example">
      <CMP> The initial values use these paths:</CMP>
    </assertion><assertion class="example">
      <CMP> 1 -&gt; 4 -&gt; 2 -&gt; 7 -&gt; 22 -&gt; 11.</CMP>
    </assertion><assertion class="example">
      <CMP> 1 -&gt; 4 -&gt; 13 -&gt; 40 -&gt; 20 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8.</CMP>
    </assertion><assertion class="example">
      <CMP> 1 -&gt; 4 -&gt; 13 -&gt; 40 -&gt; 20 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 49 -&gt; 148 -&gt; 74 -&gt; 37 -&gt; 12 -&gt; 56 -&gt; 28 -&gt; 14.</CMP>
    </assertion><omtext class="maple">
      <CMP> # Code from David Applegate: Be careful - the function takes an iteration limit and returns the limit if it wasn't able to determine the answer (that is, if A125731(n,lim) == lim, all you know is that the value is &gt;= lim). To use it, do manual iteration on the limit.</CMP>
    </omtext><omtext class="maple">
      <CMP> A125731 := proc(n,lim) local d,d2; options remember;</CMP>
    </omtext><omtext class="maple">
      <CMP> if (n = 1) then return 0; end if;</CMP>
    </omtext><omtext class="maple">
      <CMP> if (n mod 3 = 0) then return -1; end if;</CMP>
    </omtext><omtext class="maple">
      <CMP> if (lim &lt;= 0) then return 0; end if;</CMP>
    </omtext><omtext class="maple">
      <CMP> if (n &gt; (3 ** (lim+1) - 1)/2) then return lim; end if;</CMP>
    </omtext><omtext class="maple">
      <CMP> if (n mod 9 = 4 or n mod 9 = 7) then</CMP>
    </omtext><omtext class="maple">
      <CMP> d := A125731((n-1)/3,lim-1);</CMP>
    </omtext><omtext class="maple">
      <CMP> d2 := A125731(2*n,d);</CMP>
    </omtext><omtext class="maple">
      <CMP> if (d2 &lt; d) then d := d2; end if;</CMP>
    </omtext><omtext class="maple">
      <CMP> else</CMP>
    </omtext><omtext class="maple">
      <CMP> d := A125731(2*n,lim-1);</CMP>
    </omtext><omtext class="maple">
      <CMP> end if;</CMP>
    </omtext><omtext class="maple">
      <CMP> return 1+d;</CMP>
    </omtext><omtext class="maple">
      <CMP> end proc;</CMP>
    </omtext><assertion class="keywords">
      <CMP> sign</CMP>
    </assertion><assertion class="offset">
      <CMP> 1,2</CMP>
    </assertion><assertion class="author">
      <CMP> _David Applegate_ and _N. J. A. Sloane_, Feb 02 2007</CMP>
    </assertion>
        </theory>
      </omdoc>