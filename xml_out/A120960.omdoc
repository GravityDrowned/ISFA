<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A120960.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A120960">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 5,13,17,25,29,37,41,53,61,73,89,97,101,109,113,125,137,149,157,169,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 173,181,193,197,229,233,241,257,269,277,281,289,293,313,317,337,349,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 353,373,389,397,401,409,421,433,449,457,461,509,521,541,557,569,577,593</CMP>
    </assertion><omtext class="name">
      <CMP> Pythagorean prime powers.</CMP>
    </omtext><omtext class="comment">
      <CMP> 1 + sum of the indices of the first two numbers in A001844 that are divisible by n, if 1 + the sum of those indices equals n. - _Mats Granvik_, Oct 16 2007</CMP>
    </omtext><omtext class="comment">
      <CMP> R. J. Turyn proved [Baliga, et al., p. 129, gives the reference] that Williamson Hadamard matrices exist for 4t = 2(p^k + 1), for all primes p such that p == 1 (mod 4). - _L. Edson Jeffery_, Apr 10 2012</CMP>
    </omtext><omtext class="comment">
      <CMP> A024362(a(n)) = 1. - _Reinhard Zumkeller_, Dec 02 2012</CMP>
    </omtext><omtext class="link">
      <CMP> Reinhard Zumkeller, &lt;a href=&quot;/A120960/b120960.txt&quot;&gt;Table of n, a(n) for n = 1..1000&lt;/a&gt;</CMP>
    </omtext><omtext class="link">
      <CMP> A. Baliga and K. J. Horadam, &lt;a href=&quot;http://ajc.maths.uq.edu.au/pdf/11/ocr-ajc-v11-p123.pdf&quot;&gt;Cocyclic Hadamard matrices over Z_t X Z^2_2&lt;/a&gt;, Australas. J. Combin. 11(1995), 123-134.</CMP>
    </omtext><omtext class="link">
      <CMP> Eric Weisstein's World of Mathematics, MathWorld, &lt;a href=&quot;http://mathworld.wolfram.com/CenteredSquareNumber.html&quot;&gt;Centered Square Number&lt;/a&gt;.</CMP>
    </omtext><assertion class="example">
      <CMP> A001844(1) = 5 is divisible by 5, A001844(3) = 25 is divisible by = 5 and 1+3+1=5, so 5 is a member.</CMP>
    </assertion><assertion class="example">
      <CMP> A001844(2) = 13 is divisible by = 13, A001844(10) = 221 is divisible by = 13 and 2+10+1=13 so 13 is a member.</CMP>
    </assertion><omtext class="program">
      <CMP> (Excel cell formula) Generate the indices with: =if(mod(1+2*row()*(row()+1);4*column()+1)=0;row();&quot;) Then sum the first two indices if it equals the column + 1. - _Mats Granvik_, Oct 16 2007</CMP>
    </omtext><omtext class="program">
      <CMP> (Haskell)</CMP>
    </omtext><omtext class="program">
      <CMP> import Data.List (elemIndices)</CMP>
    </omtext><omtext class="program">
      <CMP> a120960 n = a120960_list !! (n-1)</CMP>
    </omtext><omtext class="program">
      <CMP> a120960_list = map (+ 1) $ elemIndices 1 a024362_list</CMP>
    </omtext><omtext class="program">
      <CMP> -- _Reinhard Zumkeller_, Dec 02 2012</CMP>
    </omtext><assertion class="crossref">
      <CMP> Cf. A002144.</CMP>
    </assertion><assertion class="crossref">
      <CMP> Cf. A001844, subsequence of A000961.</CMP>
    </assertion><assertion class="crossref">
      <CMP> Cf. A024409, subsequence of A008846.</CMP>
    </assertion><assertion class="keywords">
      <CMP> nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 1,1</CMP>
    </assertion><assertion class="author">
      <CMP> _Lekraj Beedassy_, Jul 19 2006</CMP>
    </assertion>
        </theory>
      </omdoc>