<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A221947.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A221947">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 3,3,423,3,81,423,75,3,0,81,11003,423,155,75,35,3,239,0,151,81,23,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 11003,21,423,21,155,341,75,201,35,75,3,21,239,15,0,113,151,21,81,635,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 23,1131,11003,2017,21,75,423,1267,21,75,155,253,341,151,75,7931,201,75,35,69,75,213,3,1073,21,423,239,61,15</CMP>
    </assertion><omtext class="name">
      <CMP> Smallest number k (different from a power of 2) such that A006577(n*k) = A006577(n) + A006577(k),or 0 if no such number exists.</CMP>
    </omtext><omtext class="comment">
      <CMP> A006577 is the number of halving and tripling steps to reach 1 in `3x+1' problem. If n is a power of 2, a(n) = 3.</CMP>
    </omtext><omtext class="comment">
      <CMP> If  k is a powers of 2, we obtain trivial results, for example A006577(n*2^m) = A006577(2^m) + A006577(n) = m + A006577(n) =&gt; the smallest k is 1.</CMP>
    </omtext><omtext class="comment">
      <CMP> It appears that a(n) = 0 for n of the form 9*2^a = 9, 18, 36, 72,â€¦</CMP>
    </omtext><assertion class="example">
      <CMP> a(3) = 423 because A006577(3*423) = A006577(1269) = 39, and A006577(3) + A006577(423) = 7 + 32 = 39.</CMP>
    </assertion><omtext class="maple">
      <CMP> lst:={ }:C:= proc(n) a := 0 ; x := n ; while x &gt; 1 do if type(x, 'even') then x := x/2:a:=a+1:  else x := 3*x+1 ; a := a+1 ; end if; end do; a ; end proc:</CMP>
    </omtext><omtext class="maple">
      <CMP> for m from 0 to 40 do:lst:=lst union {2^m}:od:for n from 1 to 73 do: ii:=0:for k from 2 to 50000 while(ii=0) do:z:=n*k : if {k} intersect lst = {} and C(z)=C(n)+C(k) then ii:=1: printf ( &quot;%d %d \n&quot;,n,k):else fi:od: if ii=0 and {n} intersect lst = {} and {k} intersect lst = {} then printf ( &quot;%d %d \n&quot;,n,0):else fi:od:</CMP>
    </omtext><assertion class="crossref">
      <CMP> Cf. A006577, A057716.</CMP>
    </assertion><assertion class="keywords">
      <CMP> nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 1,1</CMP>
    </assertion><assertion class="author">
      <CMP> _Michel Lagneau_, Feb 25 2013</CMP>
    </assertion>
        </theory>
      </omdoc>