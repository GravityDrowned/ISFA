<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A182106.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A182106">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 1,1,2,2,9,2,46,2,250,37,254,2,31052,2,1480,896,306174,2,2097506,2,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 6025516,6638,59930,2</CMP>
    </assertion><omtext class="name">
      <CMP> Number of tilings of an n X n square with rectangles with integer sides and area n.</CMP>
    </omtext><omtext class="link">
      <CMP> &lt;a href=&quot;http://math.stackexchange.com/questions/130758&quot;&gt;Dividing a square into equal-sized rectangles&lt;/a&gt; at math.stackexchange</CMP>
    </omtext><omtext class="program">
      <CMP> (Java)</CMP>
    </omtext><omtext class="program">
      <CMP> public class Question130758 {</CMP>
    </omtext><omtext class="program">
      <CMP>     final static int maxn = 23;</CMP>
    </omtext><omtext class="program">
      <CMP>     static int n;</CMP>
    </omtext><omtext class="program">
      <CMP>     static int [] divisors = new int [maxn];</CMP>
    </omtext><omtext class="program">
      <CMP>     static int ndivisors;</CMP>
    </omtext><omtext class="program">
      <CMP>     static boolean [] [] grid;</CMP>
    </omtext><omtext class="program">
      <CMP>     static int count;</CMP>
    </omtext><omtext class="program">
      <CMP>     public static void main (String [] args) {</CMP>
    </omtext><omtext class="program">
      <CMP>         for (n = 0;n &lt;= maxn;n++) {</CMP>
    </omtext><omtext class="program">
      <CMP>             ndivisors = 0;</CMP>
    </omtext><omtext class="program">
      <CMP>             for (int divisor = 1;divisor &lt;= n;divisor++)</CMP>
    </omtext><omtext class="program">
      <CMP>                 if (n % divisor == 0)</CMP>
    </omtext><omtext class="program">
      <CMP>                     divisors [ndivisors++] = divisor;</CMP>
    </omtext><omtext class="program">
      <CMP>             grid = new boolean [n] [n];</CMP>
    </omtext><omtext class="program">
      <CMP>             count = 0;</CMP>
    </omtext><omtext class="program">
      <CMP>             recurse (0,0,0);</CMP>
    </omtext><omtext class="program">
      <CMP>             System.out.print (count + &quot;,&quot;);</CMP>
    </omtext><omtext class="program">
      <CMP>         }</CMP>
    </omtext><omtext class="program">
      <CMP>         System.out.println ();</CMP>
    </omtext><omtext class="program">
      <CMP>     }</CMP>
    </omtext><omtext class="program">
      <CMP>     static void recurse (int x,int y,int depth) {</CMP>
    </omtext><omtext class="program">
      <CMP>         if (depth == n) {</CMP>
    </omtext><omtext class="program">
      <CMP>             count++;</CMP>
    </omtext><omtext class="program">
      <CMP>             return;</CMP>
    </omtext><omtext class="program">
      <CMP>         }</CMP>
    </omtext><omtext class="program">
      <CMP>         while (grid [x] [y])</CMP>
    </omtext><omtext class="program">
      <CMP>             if (++x == n) {</CMP>
    </omtext><omtext class="program">
      <CMP>                 x = 0;</CMP>
    </omtext><omtext class="program">
      <CMP>                 y++;</CMP>
    </omtext><omtext class="program">
      <CMP>             }</CMP>
    </omtext><omtext class="program">
      <CMP>         outer:</CMP>
    </omtext><omtext class="program">
      <CMP>         for (int k = 0;k &lt; ndivisors;k++) {</CMP>
    </omtext><omtext class="program">
      <CMP>             int w = divisors [k];</CMP>
    </omtext><omtext class="program">
      <CMP>             int h = n / w;</CMP>
    </omtext><omtext class="program">
      <CMP>             if (x + w &gt; n || y + h &gt; n)</CMP>
    </omtext><omtext class="program">
      <CMP>                 continue;</CMP>
    </omtext><omtext class="program">
      <CMP>             for (int i = 0;i &lt; w;i++)</CMP>
    </omtext><omtext class="program">
      <CMP>                 for (int j = 0;j &lt; h;j++)</CMP>
    </omtext><omtext class="program">
      <CMP>                     if (grid [x + i] [y + j])</CMP>
    </omtext><omtext class="program">
      <CMP>                         continue outer;</CMP>
    </omtext><omtext class="program">
      <CMP>             for (int i = 0;i &lt; w;i++)</CMP>
    </omtext><omtext class="program">
      <CMP>                 for (int j = 0;j &lt; h;j++)</CMP>
    </omtext><omtext class="program">
      <CMP>                     grid [x + i] [y + j] = true;</CMP>
    </omtext><omtext class="program">
      <CMP>             recurse (x,y,depth + 1);</CMP>
    </omtext><omtext class="program">
      <CMP>             for (int i = 0;i &lt; w;i++)</CMP>
    </omtext><omtext class="program">
      <CMP>                 for (int j = 0;j &lt; h;j++)</CMP>
    </omtext><omtext class="program">
      <CMP>                     grid [x + i] [y + j] = false;</CMP>
    </omtext><omtext class="program">
      <CMP>         }</CMP>
    </omtext><omtext class="program">
      <CMP>     }</CMP>
    </omtext><omtext class="program">
      <CMP> }</CMP>
    </omtext><assertion class="crossref">
      <CMP> Diagonal of A220122. - _Alois P. Heinz_, Dec 07 2012</CMP>
    </assertion><assertion class="keywords">
      <CMP> nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 0,3</CMP>
    </assertion><assertion class="author">
      <CMP> _Felix A. Pahl_, Apr 12 2012</CMP>
    </assertion>
        </theory>
      </omdoc>