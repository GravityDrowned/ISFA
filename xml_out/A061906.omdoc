<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A061906.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A061906">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 1,1,1,1,1,1,1,1,1,1,1,1,21,38,18,35,17,16,14,9,1,12,1,7,29,21,19,37,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 9,8,1,14,66,1,8,15,7,3,13,15,1,16,6,23,1,13,9,3,44,7,1,19,13,4,518,1,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 11,3,4,13,1,442,7,4,33,9,1,11,4,6,1,845,88,4,3,7,287,1,11,6,1,12345679,8</CMP>
    </assertion><omtext class="name">
      <CMP> Obtain m by omitting trailing zeros from n; a(n) = smallest k such that k*m is a palindrome.</CMP>
    </omtext><omtext class="comment">
      <CMP> Every positive integer is a factor of a palindrome, unless it is a multiple of 10 (D. G. Radcliffe, see Links).</CMP>
    </omtext><omtext class="comment">
      <CMP> Every integer n has a multiple of the form 99...9900...00. To see that n has a multiple that's a palindrome (allowing 0's on the left) with even digits, let 9n divide 99...9900...00; then n divides 22...2200...00. - _Dean Hickerson_, Jun 29 2001</CMP>
    </omtext><omtext class="link">
      <CMP> Chai Wah Wu, &lt;a href=&quot;/A061906/b061906.txt&quot;&gt;Table of n, a(n) for n = 0..8180&lt;/a&gt;</CMP>
    </omtext><omtext class="link">
      <CMP> P. De Geest, &lt;a href=&quot;http://www.worldofnumbers.com/em36.htm&quot;&gt;Smallest multipliers to make a number palindromic&lt;/a&gt;.</CMP>
    </omtext><assertion class="example">
      <CMP> For n = 30 we have m = 3, 1*m = 3 is a palindrome, so a(30) = 1. For n = m = 12 the smallest palindromic multiple is 21*m = 252, so a(12) = 21.</CMP>
    </assertion><omtext class="program">
      <CMP> (ARIBAS): stop := 20000000; for n := 0 to maxarg do k := 1; test := true; while test and k &lt; stop do mp := omit_trailzeros(n)*k; if test := mp &lt;&gt; int_reverse(mp) then inc(k); end; end; if k &lt; stop then write(k,&quot; &quot;); else write(-1,&quot; &quot;); end; end;</CMP>
    </omtext><omtext class="program">
      <CMP> (Python)</CMP>
    </omtext><omtext class="program">
      <CMP> from __future__ import division</CMP>
    </omtext><omtext class="program">
      <CMP> def palgen(l, b=10): # generator of palindromes in base b of length &lt;= 2*l</CMP>
    </omtext><omtext class="program">
      <CMP> ....if l &gt; 0:</CMP>
    </omtext><omtext class="program">
      <CMP> ........yield 0</CMP>
    </omtext><omtext class="program">
      <CMP> ........for x in range(1, l+1):</CMP>
    </omtext><omtext class="program">
      <CMP> ............n = b**(x-1)</CMP>
    </omtext><omtext class="program">
      <CMP> ............n2 = n*b</CMP>
    </omtext><omtext class="program">
      <CMP> ............for y in range(n, n2):</CMP>
    </omtext><omtext class="program">
      <CMP> ................k, m = y//b, 0</CMP>
    </omtext><omtext class="program">
      <CMP> ................while k &gt;= b:</CMP>
    </omtext><omtext class="program">
      <CMP> ....................k, r = divmod(k, b)</CMP>
    </omtext><omtext class="program">
      <CMP> ....................m = b*m + r</CMP>
    </omtext><omtext class="program">
      <CMP> ................yield y*n + b*m + k</CMP>
    </omtext><omtext class="program">
      <CMP> ............for y in range(n, n2):</CMP>
    </omtext><omtext class="program">
      <CMP> ................k, m = y, 0</CMP>
    </omtext><omtext class="program">
      <CMP> ................while k &gt;= b:</CMP>
    </omtext><omtext class="program">
      <CMP> ....................k, r = divmod(k, b)</CMP>
    </omtext><omtext class="program">
      <CMP> ....................m = b*m + r</CMP>
    </omtext><omtext class="program">
      <CMP> ................yield y*n2 + b*m + k</CMP>
    </omtext><omtext class="program">
      <CMP> def A050782(n, l=10):</CMP>
    </omtext><omtext class="program">
      <CMP> ....if n % 10:</CMP>
    </omtext><omtext class="program">
      <CMP> ........x = palgen(l)</CMP>
    </omtext><omtext class="program">
      <CMP> ........next(x)  # replace with x.next() in Python 2.x</CMP>
    </omtext><omtext class="program">
      <CMP> ........for i in x:</CMP>
    </omtext><omtext class="program">
      <CMP> ............q, r = divmod(i, n)</CMP>
    </omtext><omtext class="program">
      <CMP> ............if not r:</CMP>
    </omtext><omtext class="program">
      <CMP> ................return q</CMP>
    </omtext><omtext class="program">
      <CMP> ........else:</CMP>
    </omtext><omtext class="program">
      <CMP> ............return 'search limit reached.'</CMP>
    </omtext><omtext class="program">
      <CMP> ....else:</CMP>
    </omtext><omtext class="program">
      <CMP> ........return 0</CMP>
    </omtext><omtext class="program">
      <CMP> def A061906(n, l=10):</CMP>
    </omtext><omtext class="program">
      <CMP> ....return A050782(int(str(n).rstrip('0')),l) if n &gt; 0 else 1</CMP>
    </omtext><omtext class="program">
      <CMP> # _Chai Wah Wu_, Dec 30 2014</CMP>
    </omtext><assertion class="crossref">
      <CMP> Cf. A050782, A062293, A061915, A061916, A061816. Values of k*m are given in A061906.</CMP>
    </assertion><assertion class="keywords">
      <CMP> base,easy,nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 0,13</CMP>
    </assertion><assertion class="author">
      <CMP> _Klaus Brockhaus_, Jun 25 2001</CMP>
    </assertion>
        </theory>
      </omdoc>