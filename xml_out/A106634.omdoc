<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A106634.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A106634">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 1,6,21,32,62,58,124,88,173,158,226,156,380,194,340,356,466,274,613,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 316,690,536,596,404,1060,552,734,728,1032,546,1376,596,1213,932,1026,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 976,1858,750,1180,1144,1910,854,2048,908,1784,1730,1500,1016,2800</CMP>
    </assertion><omtext class="name">
      <CMP> Number of ways to express n as i*j+k*l, with i,j,k,l in the range [0..n].</CMP>
    </omtext><omtext class="comment">
      <CMP> Number of ordered 4-tuples [i,j,k,l] with n=i*j+k*l and i,j,k,l in the range [0..n].</CMP>
    </omtext><omtext class="comment">
      <CMP> a(n) is odd iff n is in A001105.</CMP>
    </omtext><omtext class="link">
      <CMP> R. J. Mathar and Charles R Greathouse IV, &lt;a href=&quot;/A106634/b106634.txt&quot;&gt;Table of n, a(n) for n = 0..10000&lt;/a&gt; (terms through 780 from Mathar)</CMP>
    </omtext><assertion class="example">
      <CMP> a(1)=6: the 4-tuples ijkl are 1100, 1101, 1110, 0011, 0111, 1011.</CMP>
    </assertion><assertion class="example">
      <CMP> a(2)=21: 1111, 2100, 210x, 21x0, 1200, 120x, 12x0, where x = 1 or 2, and ten more with the two halves swapped.</CMP>
    </assertion><omtext class="maple">
      <CMP> A106634 := proc(n)</CMP>
    </omtext><omtext class="maple">
      <CMP>     local a,i,j,k,l ;</CMP>
    </omtext><omtext class="maple">
      <CMP>     a := 0 ;</CMP>
    </omtext><omtext class="maple">
      <CMP>     for i from 0 to n do</CMP>
    </omtext><omtext class="maple">
      <CMP>         for j from 0 to n do</CMP>
    </omtext><omtext class="maple">
      <CMP>             if i*j &gt; n then</CMP>
    </omtext><omtext class="maple">
      <CMP>                 break;</CMP>
    </omtext><omtext class="maple">
      <CMP>             end if;</CMP>
    </omtext><omtext class="maple">
      <CMP>             for k from 0 to n do</CMP>
    </omtext><omtext class="maple">
      <CMP>                 if i*j = n then</CMP>
    </omtext><omtext class="maple">
      <CMP>                     # treat l=0 separately</CMP>
    </omtext><omtext class="maple">
      <CMP>                     a := a+1 ;</CMP>
    </omtext><omtext class="maple">
      <CMP>                 end if;</CMP>
    </omtext><omtext class="maple">
      <CMP>                 # l=1..n</CMP>
    </omtext><omtext class="maple">
      <CMP>                 if k =0 then</CMP>
    </omtext><omtext class="maple">
      <CMP>                     if i*j=n then</CMP>
    </omtext><omtext class="maple">
      <CMP>                         a := a+n ;</CMP>
    </omtext><omtext class="maple">
      <CMP>                     end if;</CMP>
    </omtext><omtext class="maple">
      <CMP>                 else</CMP>
    </omtext><omtext class="maple">
      <CMP>                     l := (n-i*j)/k ;</CMP>
    </omtext><omtext class="maple">
      <CMP>                     if l &gt;=1 and l &lt;=n and type(l,'integer') then</CMP>
    </omtext><omtext class="maple">
      <CMP>                         a := a+1 ;</CMP>
    </omtext><omtext class="maple">
      <CMP>                     end if;</CMP>
    </omtext><omtext class="maple">
      <CMP>                 end if;</CMP>
    </omtext><omtext class="maple">
      <CMP>             end do:</CMP>
    </omtext><omtext class="maple">
      <CMP>         end do:</CMP>
    </omtext><omtext class="maple">
      <CMP>     end do:</CMP>
    </omtext><omtext class="maple">
      <CMP>     a ;</CMP>
    </omtext><omtext class="maple">
      <CMP> end proc: # _R. J. Mathar_, Oct 17 2012</CMP>
    </omtext><omtext class="program">
      <CMP> (PARI) list(n)={</CMP>
    </omtext><omtext class="program">
      <CMP>     my(v=vector(n));</CMP>
    </omtext><omtext class="program">
      <CMP>     for(i=2,n,for(j=1,min(n\i,i-1),v[i*j]+=2));</CMP>
    </omtext><omtext class="program">
      <CMP>     for(i=1,sqrtint(n),v[i^2]++);</CMP>
    </omtext><omtext class="program">
      <CMP>     concat(1,vector(n,i,2*sum(j=i\2+1,i-1,v[j]*v[i-j])+if(i%2,,v[i/2]^2)+(4*i+2)*v[i]))</CMP>
    </omtext><omtext class="program">
      <CMP> }; \\ _Charles R Greathouse IV_, Oct 17 2012</CMP>
    </omtext><assertion class="crossref">
      <CMP> Cf. A001105, A055507, A106633, A106846, A106847.</CMP>
    </assertion><assertion class="keywords">
      <CMP> nonn,easy</CMP>
    </assertion><assertion class="offset">
      <CMP> 0,2</CMP>
    </assertion><assertion class="author">
      <CMP> _Ralf Stephan_, May 06 2005</CMP>
    </assertion><assertion class="extensions">
      <CMP> Definition clarified by _N. J. A. Sloane_, Jul 07 2012</CMP>
    </assertion>
        </theory>
      </omdoc>