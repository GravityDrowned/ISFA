<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A095180.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A095180">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 2,3,5,7,11,31,71,13,73,17,37,97,79,101,701,311,131,941,151,751,761,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 971,181,191,991,113,313,733,743,353,953,373,383,983,107,907,727,337,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 937,347,157,757,167,967,787,797,709,919,929,739,149,359,769,179,389,199</CMP>
    </assertion><omtext class="name">
      <CMP> Reverse digits of primes, append to sequence if result is a prime.</CMP>
    </omtext><omtext class="comment">
      <CMP> Conjecture: the Benford law limit is 2=Sum[N[Log[10, 1 + 1/d[[n]]]], {n, 1, Length[d]}]^2/(( #toralprimes/#totalPrimes)). At 50000 primes total it is 2.05931. - _Roger L. Bagula_ and _Gary W. Adamson_, Jul 02 2008</CMP>
    </omtext><omtext class="reference">
      <CMP> Weisstein, Eric W. &quot;Benford's Law.&quot; http://mathworld.wolfram.com/BenfordsLaw.html</CMP>
    </omtext><omtext class="link">
      <CMP> Roger L. Bagula and Gary W. Adamson, Jul 02 2008, &lt;a href=&quot;/A095180/b095180.txt&quot;&gt;Table of n, a(n) for n = 1..206&lt;/a&gt;</CMP>
    </omtext><assertion class="example">
      <CMP> The prime 107 in reverse is 701 which is prime.</CMP>
    </assertion><omtext class="mathematica">
      <CMP> b = Flatten[Table[If[PrimeQ[Sum[IntegerDigits[Prime[n]][[i]]*10^(i - 1), {i, 1, Length[IntegerDigits[Prime[n]]]}]], Sum[IntegerDigits[Prime[n]][[i]]*10^(i - 1), {i, 1, Length[IntegerDigits[Prime[n]]]}], {}], {n, 1,1000}]] (* _Roger L. Bagula_ and _Gary W. Adamson_, Jul 02 2008 *)</CMP>
    </omtext><omtext class="mathematica">
      <CMP> Select[FromDigits[Reverse[IntegerDigits[#]]]&amp;/@Prime[Range[300]],PrimeQ] (* _Harvey P. Dale_, May 05 2015 *)</CMP>
    </omtext><omtext class="program">
      <CMP> (PARI) r(n) = forprime(x=1,n,y=eval(rev(x));if(isprime(y),print1(y&quot;,&quot;))) \ Get the reverse of the input string rev(str) = { local(tmp,j,s); tmp = Vec(Str(str)); s=&quot;&quot;; forstep(j=length(tmp),1,-1, s=concat(s,tmp[j])); return(s) }</CMP>
    </omtext><omtext class="program">
      <CMP> (Haskell)</CMP>
    </omtext><omtext class="program">
      <CMP> a095180 n = a095180_list !! (n-1)</CMP>
    </omtext><omtext class="program">
      <CMP> a095180_list =filter ((== 1) . a010051) a004087_list</CMP>
    </omtext><omtext class="program">
      <CMP> -- _Reinhard Zumkeller_, Oct 14 2011</CMP>
    </omtext><assertion class="crossref">
      <CMP> Cf. A007500.</CMP>
    </assertion><assertion class="crossref">
      <CMP> Cf. A004087, A010051.</CMP>
    </assertion><assertion class="keywords">
      <CMP> base,easy,nonn,changed</CMP>
    </assertion><assertion class="offset">
      <CMP> 1,1</CMP>
    </assertion><assertion class="author">
      <CMP> _Cino Hilliard_, Jun 21 2004</CMP>
    </assertion>
        </theory>
      </omdoc>