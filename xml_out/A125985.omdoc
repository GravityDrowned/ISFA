<?xml version='1.0' encoding='UTF-8'?>
<omdoc xml:id="A125985.omdoc" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:omdoc="http://omdoc.org/ns" xmlns="http://omdoc.org/ns">
        <!--This OMDoc file is generated from an OEIS entry, do not edit-->
        <theory name="A125985">
          <assertion class="***** TTTT *****">
      <CMP></CMP>
    </assertion><omtext class="starts-with">
      <CMP> 0,1,3,2,8,7,5,6,4,22,21,18,20,17,13,12,19,15,16,10,11,14,9,64,63,59,</CMP>
    </omtext><assertion class="***** UUUU *****">
      <CMP> 62,58,50,49,61,55,57,46,48,54,45,36,35,32,34,31,60,56,41,52,40,47,53,</CMP>
    </assertion><assertion class="***** IIII *****">
      <CMP> 43,44,27,26,33,29,30,51,38,39,42,24,25,28,37,23,196,195,190,194,189</CMP>
    </assertion><omtext class="name">
      <CMP> Signature-permutation of Vaille's 1997 bijection on 'bridges' (Dyck paths).</CMP>
    </omtext><omtext class="comment">
      <CMP> Vaille shows in 1997 paper that this automorphism transforms a 'derivation' of a Dyck path to its 'compression', i.e. in OEIS-terms A125985(A126310(n)) = A126309(A125985(n)) holds for all n. He also proves that A057515(A125985(n)) = A126307(n) and A057514(A125985(n)) = A072643(n) - A057514(n) + 1 (the latter identity for all n &gt;= 1).</CMP>
    </omtext><omtext class="reference">
      <CMP> J. Vaill\'{e}, Une Bijection Explicative de Plusieurs Proprietes Remarquables des Ponts, European J. Combin. 18 (1997), no. 1, 117-124.</CMP>
    </omtext><omtext class="link">
      <CMP> A. Karttunen, &lt;a href=&quot;/A125985/b125985.txt&quot;&gt;Table of n, a(n) for n = 0..2055&lt;/a&gt;</CMP>
    </omtext><omtext class="link">
      <CMP> &lt;a href=&quot;/index/Per#IntegerPermutationCatAuto&quot;&gt;Index entries for signature-permutations of Catalan automorphisms&lt;/a&gt;</CMP>
    </omtext><omtext class="program">
      <CMP> (Scheme:) (define (A125985 n) (A080300 (rising-list-&gt;binexp (A125985-aux2 (A014486 n)))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (A125985-aux2 n) (let loop ((lists (A125985-aux1 n)) (z (list)) (m 1)) (if (null? lists) z (loop (cdr lists) (m-join z (car lists) m) (+ m 1)))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (A125985-aux1 n) (if (zero? n) (list) (let ((begin_from (&lt;&lt; 1 (- (- (A000523 n) (A090996 n)) 1)))) (let loop ((s (A090996 n)) (t 0) (nth_list 1) (p begin_from) (b (if (= 0 (A004198bi n begin_from)) 0 1)) (lists (list (list)))) (cond ((&lt; s 1) (cond ((&lt; p 1) (reverse! lists)) (else (loop (- t (- 1 b)) b (+ 1 nth_list) (&gt;&gt; p 1) (if (= 0 (A004198bi n (&gt;&gt; p 1))) 0 1) (cons (list (+ b 1 nth_list)) lists))))) (else (loop (- s (- 1 b)) (+ t b) nth_list (&gt;&gt; p 1) (if (= 0 (A004198bi n (&gt;&gt; p 1))) 0 1) (cons (cons (+ b nth_list) (car lists)) (cdr lists)))))))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (A125985-aux2 n) (let loop ((lists (A125985-aux1 n)) (z (list)) (m 1)) (if (null? lists) z (loop (cdr lists) (m-join z (car lists) m) (+ m 1)))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (m-join a b m) (let loop ((a a) (b b) (c (list))) (cond ((and (not (pair? a)) (not (pair? b))) (reverse! c)) ((not (pair? a)) (loop a (cdr b) (cons (car b) c))) ((not (pair? b)) (loop (cdr a) b (cons (car a) c))) ((equal? (car a) (car b)) (loop (cdr a) (cdr b) (cons (car a) c))) ((&gt; (car b) m) (loop a (cdr b) (cons (car b) c))) (else (loop (cdr a) b (cons (car a) c))))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (rising-list-&gt;binexp rising-list) (let loop ((s 0) (i 0) (h 0) (fs rising-list)) (cond ((null? fs) (+ s (&lt;&lt; (- (&lt;&lt; 1 h) 1) i))) ((&gt; (car fs) h) (loop s (+ i 1) (car fs) (cdr fs))) (else (loop (+ s (&lt;&lt; (- (&lt;&lt; 1 (+ 1 (- h (car fs)))) 1) i)) (+ i 2 (- h (car fs))) (car fs) (cdr fs))))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (&gt;&gt; n i) (if (zero? i) n (&gt;&gt; (floor-&gt;exact (/ n 2)) (- i 1))))</CMP>
    </omtext><omtext class="program">
      <CMP> (define (&lt;&lt; n i) (if (&lt;= i 0) (&gt;&gt; n (- i)) (&lt;&lt; (+ n n) (- i 1))))</CMP>
    </omtext><assertion class="crossref">
      <CMP> Inverse: A125986. The number of cycles, maximum cycle sizes and LCM's of all cycle sizes in range [A014137(n-1)..A014138(n-1)] of this permutation are given by A126291, A126292 and A126293. The fixed points are given by A126300/A126301.</CMP>
    </assertion><assertion class="keywords">
      <CMP> nonn</CMP>
    </assertion><assertion class="offset">
      <CMP> 0,3</CMP>
    </assertion><assertion class="author">
      <CMP> _Antti Karttunen_, Jan 02 2007</CMP>
    </assertion>
        </theory>
      </omdoc>